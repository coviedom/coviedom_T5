/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 *
 * Assert works like
 * if(condition){
 * 		// then is true, and codes executes.
 * }else
 * {
 * 		// code breaks
 * }
 *
 * (assert(condition) -> if condition is not true, the code braks...)
 *
 ******************************************************************************
 */
#include <stdint.h>
#include "stm32f4xx_hal.h"
#include "stm32_assert.h"
#include "gpio_driver_hal.h"

// Headers definition
int add(int x, int y);

// Definimos un PIN de prueba
GPIO_Handler_t userLed = {0}; // PinA5

/*
 * The main function, where everything happens.
 *  */
int main(void)
{
	/* Configuramos el pin */
	userLed.pGPIOx							= GPIOA;
	userLed.pinConfig.GPIO_PinNumber		= PIN_5;
	userLed.pinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	userLed.pinConfig.GPIO_PinOutputType	= GPIO_OTYPE_PUSHPULL;
	userLed.pinConfig.GPIO_PinOutputSpeed	= GPIO_OSPEED_MEDIUM;
	userLed.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;

	/* Cargamos la configuración en los registros que gobiernan el puerto */
	gpio_Config(&userLed);

	gpio_WritePin(&userLed, SET);


	while(1){
		gpio_TooglePin(&userLed);

	}
}

/*
 * Esta función sirve para detectar problemas de parámetros
 * incorrectos al momento de ejecutar un programa.
 * */
void assert_failed(uint8_t* file, uint32_t line){
	while(1){
		// Problems...
	}
}
/* Respuestas a punto 1:
 *
 * ¿Cúal es este error o errores?
 *
 * R/ Hay 2 errores, los cuales se encuentran en la linea 250 y 251 del archivo gpio_driver_hal.c,
 * el primero es que se carga el valor del registro IDR, desplazado a IZQUIERDA tantas veces como
 * la ubicación del pin específico, lo cual es erroneo ya que esto no es un procedimiento
 * correcto si lo que se requiere es leer el estado de un pin específico. Esto NO seria
 * eficiente, ya que va a requerir más pasos de codigo. Este paso se sale de la dirección
 * de cumplir el objetivo.
 * El segundo error es que se asigna pinValue a pinValue, esta linea de codigo no hace algo
 * productivo, haciendo que la funcion gpio_ReadPin()no permita conocer el estado de un pin
 * especifico.
 *
 * ¿Cómo se pueden solucionar?
 *
 * R/ El primer error se soluciona simplemente aplicando el operador de desplazamiento a la
 * derecha shift (>>) lo que hace que se cargue el valor del registro IDR, desplazado a
 * DERECHA tantas veces como la ubicación del pin específico, esto simplifica mucho el trabajo
 * ya que va a ser más facil acceder a él.
 * El segundo error se soluciona haciendo que el resultado del paso anterior opere con una
 * operación AND (&) bitwise con un 0b1, ya que su resultado nos permitirá conocer unicamente el
 * el estado del pin específico, y asi entonces asignarlo nuevamente a pinValue para ser retornado.
 *
 */
