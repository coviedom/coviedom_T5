/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 *
 * Assert works like
 * if(condition){
 * 		// then is true, and codes executes.
 * }else
 * {
 * 		// code breaks
 * }
 *
 * (assert(condition) -> if condition is not true, the code braks...)
 *
 ******************************************************************************
 */
#include <stdint.h>
#include "stm32f4xx_hal.h"
#include "stm32_assert.h"
#include "gpio_driver_hal.h"

// Headers definition
int add(int x, int y);

// Definimos los pines
GPIO_Handler_t userLed = {0}; // PinA5 pin para la solucion del segundo punto
GPIO_Handler_t userLed0 = {0}; // PinA7
GPIO_Handler_t userLed1 = {0}; // PinC8
GPIO_Handler_t userLed2 = {0}; // PinC7
GPIO_Handler_t userLed3 = {0}; // PinA6
GPIO_Handler_t userLed4 = {0}; // PinB8
GPIO_Handler_t userLed5 = {0}; // PinC6
GPIO_Handler_t userLed6 = {0}; // PinC9
GPIO_Handler_t UserBOTON = {0};// Boton

// Definimos todas las variables a utilizar.
uint8_t time = 0;
uint8_t USER_BOTON = 0;
uint8_t bit0 = 0;
uint8_t bit1 = 0;
uint8_t bit2 = 0;
uint8_t bit3 = 0;
uint8_t bit4 = 0;
uint8_t bit5 = 0;
uint8_t bit6 = 0;

// Definicion de funcion lightLed, luego se la va a utilizar
void lightLed(uint8_t time);


/*
 * The main function, where everything happens.
 *  */
int main(void)
{
	/* Configuramos el pin de prueba para el punto 2 */
	userLed.pGPIOx							= GPIOA;
	userLed.pinConfig.GPIO_PinNumber		= PIN_5;
	userLed.pinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	userLed.pinConfig.GPIO_PinOutputType	= GPIO_OTYPE_PUSHPULL;
	userLed.pinConfig.GPIO_PinOutputSpeed	= GPIO_OSPEED_MEDIUM;
	userLed.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;

	/* Configuramos el pin A7*/
	userLed0.pGPIOx							= GPIOA;
	userLed0.pinConfig.GPIO_PinNumber		= PIN_7;
	userLed0.pinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	userLed0.pinConfig.GPIO_PinOutputType	= GPIO_OTYPE_PUSHPULL;
	userLed0.pinConfig.GPIO_PinOutputSpeed	= GPIO_OSPEED_MEDIUM;
	userLed0.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;


	/* Configuramos el pin C8 */
	userLed1.pGPIOx							= GPIOC;
	userLed1.pinConfig.GPIO_PinNumber		= PIN_8;
	userLed1.pinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	userLed1.pinConfig.GPIO_PinOutputType	= GPIO_OTYPE_PUSHPULL;
	userLed1.pinConfig.GPIO_PinOutputSpeed	= GPIO_OSPEED_MEDIUM;
	userLed1.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;

	/* Configuramos el pin C7*/
	userLed2.pGPIOx							= GPIOC;
	userLed2.pinConfig.GPIO_PinNumber		= PIN_7;
	userLed2.pinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	userLed2.pinConfig.GPIO_PinOutputType	= GPIO_OTYPE_PUSHPULL;
	userLed2.pinConfig.GPIO_PinOutputSpeed	= GPIO_OSPEED_MEDIUM;
	userLed2.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;

	/* Configuramos el pin A6*/
	userLed3.pGPIOx							= GPIOA;
	userLed3.pinConfig.GPIO_PinNumber		= PIN_6;
	userLed3.pinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	userLed3.pinConfig.GPIO_PinOutputType	= GPIO_OTYPE_PUSHPULL;
	userLed3.pinConfig.GPIO_PinOutputSpeed	= GPIO_OSPEED_MEDIUM;
	userLed3.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;

	/* Configuramos el pin B8*/
	userLed4.pGPIOx							= GPIOB;
	userLed4.pinConfig.GPIO_PinNumber		= PIN_8;
	userLed4.pinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	userLed4.pinConfig.GPIO_PinOutputType	= GPIO_OTYPE_PUSHPULL;
	userLed4.pinConfig.GPIO_PinOutputSpeed	= GPIO_OSPEED_MEDIUM;
	userLed4.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;

	/* Configuramos el pin C6*/
	userLed5.pGPIOx							= GPIOC;
	userLed5.pinConfig.GPIO_PinNumber		= PIN_6;
	userLed5.pinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	userLed5.pinConfig.GPIO_PinOutputType	= GPIO_OTYPE_PUSHPULL;
	userLed5.pinConfig.GPIO_PinOutputSpeed	= GPIO_OSPEED_MEDIUM;
	userLed5.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;

	/* Configuramos el pin C9*/
	userLed6.pGPIOx							= GPIOC;
	userLed6.pinConfig.GPIO_PinNumber		= PIN_9;
	userLed6.pinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	userLed6.pinConfig.GPIO_PinOutputType	= GPIO_OTYPE_PUSHPULL;
	userLed6.pinConfig.GPIO_PinOutputSpeed	= GPIO_OSPEED_MEDIUM;
	userLed6.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;

	// Se configura el Pin Del boton que cual se encuentra en PC13 (Puerto GPIOC Pin 13).
	UserBOTON.pGPIOx = GPIOC;
	UserBOTON.pinConfig.GPIO_PinNumber			= PIN_13;
	UserBOTON.pinConfig.GPIO_PinMode			= GPIO_MODE_IN;
	UserBOTON.pinConfig.GPIO_PinOutputType		= GPIO_OTYPE_PUSHPULL;
	UserBOTON.pinConfig.GPIO_PinPuPdControl	    = GPIO_PUPDR_NOTHING;
	UserBOTON.pinConfig.GPIO_PinOutputSpeed		= GPIO_OSPEED_FAST;
	UserBOTON.pinConfig.GPIO_PinAltFunMode		= AF0;


	/* Cargamos la configuración en los registros que gobiernan el puerto */
	gpio_Config(&userLed);
	gpio_Config(&userLed0);
	gpio_Config(&userLed1);
	gpio_Config(&userLed2);
	gpio_Config(&userLed3);
	gpio_Config(&userLed4);
	gpio_Config(&userLed5);
	gpio_Config(&userLed6);
	gpio_Config(&UserBOTON);

	//Haciendo que todos los pines se enciendan
	gpio_WritePin(&userLed, SET);
	gpio_WritePin(&userLed0, SET);
	gpio_WritePin(&userLed1, SET);
	gpio_WritePin(&userLed2, SET);
	gpio_WritePin(&userLed3, SET);
	gpio_WritePin(&userLed4, SET);
	gpio_WritePin(&userLed5, SET);
	gpio_WritePin(&userLed6, SET);

	// Se usa el ciclo While para que se continue ejecutando el codigo siempre
	while(1){
		//SOLUCION DEL SEGUNDO PUNTO, hay que poner un brake para ver el efecto
		gpio_TooglePin(&userLed);

		USER_BOTON = gpio_ReadPin(&UserBOTON); // Se lee el estado del boton (0 presionado, 1 sin presionar).

		lightLed(time);   //la funcion lightLed se encarga de encender o apagar cada pin

		// El contador incrementa o decrementa segun el estado del botón
		if(USER_BOTON == 1){
			time += 1;
		}else{
			time -= 1;
		}

		// Hacer que el contador se reinicie en 1 o en 60 segun sea el estado del boton
		if(time  > 60){
			time = 1;
		}
		if(time  < 1){
			time = 60;
		}

		// Que se ejecute una instruccion que no hace nada por muchas veces
		// Asi se demora aproximadamente 1 segundo.
		for (int i=0;(i < 1240000);i++){
			NOP();
		}

	}
} //fin de la funcion Main

/*
 * Esta función sirve para detectar problemas de parámetros
 * incorrectos al momento de ejecutar un programa.
 * */
void assert_failed(uint8_t* file, uint32_t line){
	while(1){
		// Problems...
	}
}
void lightLed(uint8_t time){

	bit0 = time & 0b1;
	bit1 = time & 0b1 << 1; // Acá se aplica la mascara al valor del time
	bit1 >>= 1;             // Acá se mueve el bit a la posicion 0
	bit2 = time & 0b1 << 2;
	bit2 >>= 2;
	bit3 = time & 0b1 << 3;
	bit3 >>= 3;
	bit4 = time & 0b1 << 4;
	bit4 >>= 4;
	bit5 = time & 0b1 << 5;
	bit5 >>= 5;
	bit6 = time & 0b1 << 6;
	bit6 >>= 6;

	// dependiendo del valor del bit se enciende o se apaga cada led utilizando la función GPIO_WritePin
	if(bit0 == 1){
		gpio_WritePin(&userLed0, SET);
	}else{
		gpio_WritePin(&userLed0, RESET);
	}

	if(bit1 == 1){
		gpio_WritePin(&userLed1, SET);
	}else{
		gpio_WritePin(&userLed1, RESET);
	}

	if(bit2 == 1){
		gpio_WritePin(&userLed2, SET);
	}else{
		gpio_WritePin(&userLed2, RESET);
	}

	if(bit3 == 1){
		gpio_WritePin(&userLed3, SET);
	}else{
		gpio_WritePin(&userLed3, RESET);
	}

	if(bit4 == 1){
		gpio_WritePin(&userLed4, SET);
	}else{
		gpio_WritePin(&userLed4, RESET);
	}

	if(bit5 == 1){
		gpio_WritePin(&userLed5, SET);
	}else{
		gpio_WritePin(&userLed5, RESET);
	}

	if(bit6 == 1){
		gpio_WritePin(&userLed6, SET);
	}else{
		gpio_WritePin(&userLed6, RESET);
	}
}

/* Respuestas a punto 1:
 *
 * ¿Cúal es este error o errores?
 *
 * R/ Hay 2 errores, los cuales se encuentran en la linea 250 y 251 del archivo gpio_driver_hal.c,
 * el primero es que se carga el valor del registro IDR, desplazado a IZQUIERDA tantas veces como
 * la ubicación del pin específico, lo cual es erroneo ya que esto no es un procedimiento
 * correcto si lo que se requiere es leer el estado de un pin específico. Esto NO seria
 * eficiente, ya que va a requerir más pasos de codigo. Este paso se sale de la dirección
 * de cumplir el objetivo.
 * El segundo error es que se asigna pinValue a pinValue, esta linea de codigo no hace algo
 * productivo, haciendo que la funcion gpio_ReadPin()no permita conocer el estado de un pin
 * especifico.
 *
 * ¿Cómo se pueden solucionar?
 *
 * R/ El primer error se soluciona simplemente aplicando el operador de desplazamiento a la
 * derecha shift (>>) lo que hace que se cargue el valor del registro IDR, desplazado a
 * DERECHA tantas veces como la ubicación del pin específico, esto simplifica mucho el trabajo
 * ya que va a ser más facil acceder a él.
 * El segundo error se soluciona haciendo que el resultado del paso anterior opere con una
 * operación AND (&) bitwise con un 0b1, ya que su resultado nos permitirá conocer unicamente el
 * el estado del pin específico, y asi entonces asignarlo nuevamente a pinValue para ser retornado.
 *
 */
